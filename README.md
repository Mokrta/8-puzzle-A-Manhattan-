# 8-puzzle-Astar-Manhattan-
### Файл 8pfuncs.h містить оголошення класів та визначення їх методів.
       1. Клас Stan містить масив розміром 9, що відповідає певному стану (розмішенню клітинок) поля.
              - 3 перевантажені конструктори: для автоматичного створення, для введення стану і для копіювання стану з іншого;
              - Перевантажений оператор присвоювання;
              - Переванажені оператори перевірки однаковості (==, !=);
              - Метод index_of() приймає значення клітинки, вектор, в якому шукати, і повертає індекс шуканого значення;
              - Метод distManhattan() - еврістична функція, повертає "відстань" до елемента за манхеттенським шляхом;
              - Метод print() - виводить стан у консоль.
  
       2. Клас Neighbour створений для швидкого визначення "сусідів" певного стану - тобто, які стани можна отримати з поточного за одне переміщення "нуля" (пустої клітинки). Містить контейнер - словник для швидкого пошуку "сусідніх" клітинок до обраної клітинки (тобто, з якими клітинками може помінятись місцями "нуль");
             - Конструктор заповнює словник значенням;
             - Метод indexNeighbours() - приймає індекс клітинки, і повертає вектор - всі сусіні клітинки, з якими введений може помінятись.
  
       3. Клас Node відповідає одному вузлу дерева, містить стан, вказівник на попередній (батьківський) вузол і рівень, на якому знаходиться у дереві.
             - Конструктор - приймає і присвоює значення всім полям классу;
             - Сеттери і геттери - назви кажуть самі за себе, методи для зміни і доступу прихованих полів;
             - Метод print() - виводить стан, який відповідає даному вузлу і його рівень у дереві.
        4. Клас Solver - головний клас алгоритму, який містить методи для побудови дерева й визначення найкоротшого шляху в ньому. Містить кінцевий стан, відкритий та закритий списки та логічну змінну, яка визначає, чи знайдене рішення.
             - Конструктор приймає початковий і кінцевий стани, створює з початкового ноду (вузол дерева) і додає її до відкритого списку;
             - Метод expand_node() - приймає вказівник на ноду і посилання на об'єкт класу сусідів визначає, чи є дана нода кінцевою, якщо ні, то додає всіх сусідів ноди (тобто, всі можливі перестановки нуля) ЯКИХ НЕМАЄ У ЗАКРИТОМУ СПИСКУ, щоб стани не повторювались, і додає до відкритого списку;
             - Метод next_node() - передивляється відкритий список і порівнює ноди за критерієм манхеттенського шляху за допомогою функції first_less_second() (див. Окремі функції). Визначає найближчу ноду (мінімальний шлях до стану) і виключає цей стан з відкритого списку, і додає в закритий;
             - Геттер змінної done.
             
        5. Окремі функції (Individual funcs)
             - Метод is_solviable() приймає стан й визначає чи можна з такого стану дійти до кінцевого (теорія каже про те, що з половини всіх станів не можна дістатися кінцевого, в інтернеті описаний спосіб визначення);
             - first_less_second() приймає дві ноди і порівнює їх стани за манхеттенським шляхом, повертає 1 якщо перший аргумент менше, 0 в іншому випадку;
             - isInArray() приймає стан і вектор з нодами, повертає 1 якщо у векторі є нода з заданим станом, 0 якщо ні.
